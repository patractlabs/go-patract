# Himalia PatractGo

Substrate Contract SDK for Golang As a part of Himalia

----------

PatractGo is a Golang contract SDK. In addition to supporting the basic interactive API with the contract, it mainly supports the development of micro-services based on the contract status. For example, for common ERC20 contracts, a service can be developed based on PatractGo to synchronize all transfer information to the database, and based on the database to implemente the statistics and processing of transfer data. In addition, developers can also develop some command-line tools based on Golang to assist in testing and debugging.

PatractGo will be based on [Centrifuge's GSRPC](https://github.com/centrifuge/go-substrate-rpc-client), which is a Go sdk for Substrate.

Element Group for disscusion: https://app.element.io/#/room/#PatractLabsDev:matrix.org

## Intruduction

Most contract behaviors are highly related to context. In addition to interacting with the chain, user-oriented contract applications also need to provide users with current relevant context status information:

```
+--DAPP-Front-End--------------+        +---Chain-------------------------+
|                              |        |                                 |
| +----+  +------------------+ |        | +-------+     +-------+         |
| |    |  |                  | | Commit | |       |     |       |         |
| |    |  |   Polkadot-JS    +------------> Node  +---->+ Node  |         |
| |    +->+                  | |   Tx   | |       |     |       |         |
| |    |  |                  | |        | +-------+     +----+-++         |
| |    |  +------------------+ |        |                    ^ |          |
| | UI |                       |        +---------------------------------+
| |    |  +------------------+ |                             | |
| |    |  |                  | |        +--DAPP-Server--------------------+
| |    |  |                  | |  Push  | +--------+     +-----v-------+  |
| |    +<-+   Model          +<-----------+        +-----+             |  |
| |    |  |                  | |        | | Server |     |  PatractGo  |  |
| |    |  |                  +------------>        +-----+             |  |
| +----+  +------------------+ | Query  | +----+---+     +-----+-------+  |
+------------------------------+        |      |               |          |
                                        |      |         +-----v-------+  |
                                        |      |         |             |  |
                                        |      +-------->+   DataBase  |  |
                                        |                |             |  |
                                        |                +-------------+  |
                                        |                                 |
                                        +---------------------------------+
```

PatractGo is mainly responsible for implementing micro-services in a DApp. Unlike querying the state of the chain API, PatractGo can monitor the calls and events generated by the specified contract. Developers can obtain the state storage based on this information to maintain consistent state with the chain. Through data services based on a typical API-DB architecture, the front-end DApp can efficiently and concisely obtain the state on the chain as context information.

Based on the API of chain nodes, PatractGo obtains block information and summarizes and filters it, and sends contract-related messages and events based on metadata analysis to the handler protocol specified by the developer. For example, for a typical ERC20 contract, the developer can use the channel to subscribe to all transfer events that occur, and then synchronize them into the database, so that other microservices can provide services corresponding to the token data of the account, such as querying the current token holding distribution and other logics.

Therefor, PatractGo will achieve the following support:

* Complete the secondary packaging of the contract module interface, complete operations such as `put_code`, `call`, `instantiate`, etc.
* Parse the metadata.json information of the contract, and support the automatic generation of http service interface for the metadata corresponding contract
* Scanning and monitoring support of the contract status on the chain for statistics and analysis
* Basic command line tool support for native interaction with the contract, mainly used to test the security of the contract
* SDK development examples for ERC20 contract support

## Getting Start

PatractGo based on [GSRPC](https://github.com/centrifuge/go-substrate-rpc-client), So we need install some depends:

First is subkey:

```bash
cargo install --force subkey --git https://github.com/paritytech/substrate --version 2.0.0
subkey --version
```

For Now, the sdk examples will connect to the [canvas](https://github.com/paritytech/canvas-node), and also need cli tools:

```bash
cargo install canvas-node --git https://github.com/paritytech/canvas-node.git --tag v0.1.4 --force --locked
canvas -V
```

For some examples, we can simply run a canvas node:

```bash
canvas --dev --tmp
```

use for external port:

```bash
canvas --dev --tmp  --ws-external
```

## Design

PatractGo consists of the following packages:

- `patractgo/metadata` contract metadata processing, and metadata-based contract processing
- `patractgo/rpc/native` re-encapsulation of the contract module interface to provide the contract-related interaction based on chain RPC
- `patractgo/rpc` implement the interaction with the contract based on metadata
- `patractgo/rest` implements an http service based on metadata to interact with the contract
- `patractgo/observer` Monitoring and Scanning support for contract status on the chain
- `patractgo/contracts/erc20` supports ERC20 contracts and examples
- `patractgo/tools` some tools for contracts develop

## Test

PatractGo use `go test` to test, but as need canvas environments, so need run test in one process:

```bash
go test -v -p 1 ./...
```

The unittest will start a canvas process for test, if need use a canvas start by localhost, can use this:

```bash
canvas --dev --tmp --ws-external
```

```bash
go test ./contracts/erc20/ -v -p 1 -v -args "extern" -run TestTransfer
```

This will run `TestTransfer` test to canvas

## Usage

### Contracts

Also can read: [Transfer test](https://github.com/patractlabs/go-patract/blob/master/contracts/erc20/transfer_test.go).

#### Contracts Code

**Put Code:**

```go
   // read the code wasm from file
   codeBytes, err := ioutil.ReadFile("/path/to/contracts.wasm")
   if err != nil {
      return err
   }

   // create the api
   cApi, err := rpc.NewContractAPI(env.URL())
   
   // read the abi(metadata) for contract
   metaBz, err := ioutil.ReadFile("/path/to/contracts_metadata.json")
   cApi.WithMetaData(metaBz)

   // create context with from auth, like Alice
   ctx := api.NewCtx(context.Background()).WithFrom(authKey)

   // put code
   _, err = cApi.Native().PutCode(ctx, codeBytes)
   
   // do next steps
```

**Get Code:**

```go
   codeHash := readCodeHash() // get code hash

   var codeBz []byte
   
	if err := cApi.Native().Cli.GetStorageLatest(&codeBz,
		"Contracts", "PristineCode",
		[]byte(codeHash), nil); err != nil {
		return err
   }
   
   // codeBz is now code
```

#### Instantiate

```go
	var endowment uint64 = 1000000000000

	// Instantiate
	_, contractAccount, err := cApi.Instantiate(ctx,
		types.NewCompactBalance(endowment),
		types.NewCompactGas(test.DefaultGas),
		contracts.CodeHashERC20,
		types.NewU128(totalSupply),
   )
```

api will return contractAccount, which can use to call the contract.

### Call

For a contract, we can read or exec messages:

**Read:**

Read the total_supply of ERC20 contract, no request params:

```go
	var res types.U128

	err := a.CallToRead(ctx,
		&res,
		a.ContractAccountID,
		[]string{"total_supply"},
	)
```

Read the balance_of of AccountID for ERC20 contract:

```go
	req := struct {
		Address types.AccountID
	}{
		Address: owner,
	}

	var res types.U128

	err := a.CallToRead(ctx,
		&res,
		ContractAccountIDForERC20,
		[]string{"balance_of"},
		req,
	)
```

**Exec:**

Call Transfer:

```go
	toParam := struct {
		Address AccountID
	}{
		Address: to,
	}

	valueParam := struct {
		Value U128
	}{
		Value: amt,
	}

	return a.CallToExec(ctx,
		a.ContractAccountID,
		types.NewCompactBalance(0),
		types.NewCompactGas(test.DefaultGas),
		[]string{"transfer"},
		toParam, valueParam,
	)
```

## Thanks

- [Centrifuge's GSRPC](https://github.com/centrifuge/go-substrate-rpc-client)
